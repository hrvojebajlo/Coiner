<!DOCTYPE html>
<html lang="hr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Coiner</title>
<style>
  html,body{height:100%;margin:0;background:#ffffff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  .wrap{display:flex;align-items:center;justify-content:center;height:100vh}
  canvas{background:#ffffff;image-rendering:pixelated;border:1px solid #ddd;border-radius:12px}
  #startButton{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:18px 32px;background:#ffd60a;border:none;font-size:20px;border-radius:8px;cursor:pointer;z-index:5}
  #countdown{position:absolute;top:40%;left:50%;transform:translate(-50%,-50%);font-size:96px;font-weight:900;color:#222;z-index:6;display:none}
  .hud{position:absolute;top:18px;left:50%;transform:translateX(-50%);font-weight:700;color:#111;display:flex;gap:12px;align-items:center}
  #bonusText{color:#5be07a; font-weight:900; font-size:18px; display:none;}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="gameCanvas" width="360" height="640"></canvas>
</div>
<button id="startButton">Pokreni igru</button>
<div id="countdown"></div>
<div class="hud">
  <span id="scoreLabel">Bodovi: 0</span>
  <span id="bonusText">Bonus 0s</span>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startButton = document.getElementById('startButton');
const countdownEl = document.getElementById('countdown');
const scoreLabel = document.getElementById('scoreLabel');
const bonusText = document.getElementById('bonusText');

let basket = { x: canvas.width/2 - 60/2, y: canvas.height - 88 - 20, width: 60, height: 18 };
let coins = [];
let score = 0;
let greenActive = false;
let greenTimer = 0;
let lastGreenTime = 0;
let lastRedTime = 0;
let gameOver = false;
let spawnInterval = 1200;
let lastSpawn = 0;
let coinSpeed = 80;
let lastTime = 0;

const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) audioCtx = new AudioContext();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}
function playTone(freq, duration = 0.12, type = 'square', gain = 0.12) {
  try {
    ensureAudio();
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, now);
    g.gain.setValueAtTime(gain, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + duration);
    o.connect(g);
    g.connect(audioCtx.destination);
    o.start(now);
    o.stop(now + duration + 0.02);
  } catch (e) {
    console.warn('Audio error', e);
  }
}

function playYellowSound(){ playTone(1200, 0.08, 'square', 0.08); }
function playGreenSound(){ playTone(880, 0.12, 'sine', 0.12); playTone(1320, 0.08, 'sine', 0.08); }
function playRedSound(){ playTone(260, 0.16, 'sawtooth', 0.18); }
function playTick(){ playTone(1000, 0.06, 'triangle', 0.06); }
function playStartClick(){ playTone(1400, 0.12, 'sine', 0.14); }

window.addEventListener('touchstart', ()=>{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }, {passive:true});
window.addEventListener('mousedown', ()=>{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); });

function resetGame(){
  coins = [];
  score = 0;
  greenActive = false;
  greenTimer = 0;
  lastGreenTime = 0;
  lastRedTime = 0;
  gameOver = false;
  spawnInterval = 1200;
  coinSpeed = 80;
  basket.width = 60;
  updateScoreLabel();
  updateBonusText();
}

function updateScoreLabel(){ scoreLabel.textContent = 'Bodovi: ' + score; }

function updateBonusText(){
  if(greenActive && greenTimer > 0){
    bonusText.style.display = 'inline';
    bonusText.textContent = 'Bonus ' + Math.ceil(greenTimer / 1000) + 's';
  } else {
    bonusText.style.display = 'none';
  }
}

function spawnCoin(type){
  let now = performance.now();
  if(!type){
    let yellowCount = coins.filter(c => c.type === 'yellow').length;
    let r = Math.random();
    if (yellowCount < 2 && r < 0.9) type = 'yellow';
    else if (r < 0.97 && (now - lastGreenTime) > 30000) { type = 'green'; lastGreenTime = now; }
    else if ((now - lastRedTime) > 10000){
      type = 'red';
      lastRedTime = now;
    } else {
      type = 'yellow';
    }
  }
  const padding = 14; // padding sprječava da kovanica padne izvan ekrana
  const x = Math.floor(Math.random()*(canvas.width - padding*2) + padding);
  coins.push({ x, y: -28, w: 28, h: 28, type, vy: coinSpeed * (0.9 + Math.random()*0.3) });
}

function update(dt){
  if(gameOver) return;
  const secs = dt/1000;
  for(let i = coins.length-1; i >= 0; i--){
    const c = coins[i];
    c.y += c.vy * secs;
    const coinCenterX = c.x + c.w/2;
    const basketLeft = basket.x;
    const basketRight = basket.x + basket.width;
    const catchY = basket.y;

    // Provjera hvatanja kovanica u razini košare
    if(c.y + c.h >= catchY){
      if(coinCenterX >= basketLeft && coinCenterX <= basketRight){
        if(c.type === 'yellow'){
          const pts = greenActive ? 2 : 1;
          score += pts;
          playYellowSound();
        } else if(c.type === 'green'){
          score += 2;
          greenActive = true;
          greenTimer = 10000;
          basket.width = Math.min(canvas.width-16, basket.width * 2);
          playGreenSound();
        } else if(c.type === 'red'){
          // Završava se igra SAMO ako crvena kovanica dodirne košaru na visini košare
          playRedSound();
          endGame();
        }
        coins.splice(i,1);
        updateScoreLabel();
        updateBonusText();
        continue;
      }
    }

    // ODMAH UKLONI CRVENU KOVANICU KOJA JE PROŠLA ISPOD KOŠARE (DA SE NE MOŽE UHVATITI)
    if(c.type === 'red' && c.y > basket.y + basket.height){
      coins.splice(i,1);
      continue;
    }

    // Ako kovanica padne izvan vidljivog platna (ispod ekrana)
    if(c.y > canvas.height){
      // Igra završava SAMO ako je promašena žuta kovanica
      if(c.type === 'yellow'){
        playRedSound();
        endGame();
        return;
      }
      // Za crvenu i zelenu kovanicu uklonimo bez završetka igre
      coins.splice(i,1);
      continue;
    }
  }

  // Bonus zeleni timer update
  if(greenActive){
    greenTimer -= dt;
    if(greenTimer <= 0){
      greenActive = false;
      basket.width = 60;
    }
    updateBonusText();
  }

  // Spawn kovanica
  if(performance.now() - lastSpawn > spawnInterval){
    lastSpawn = performance.now();
    spawnCoin();
    spawnInterval = Math.max(450, spawnInterval - 12);
    coinSpeed += 1.2;
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#f3f3f3';
  ctx.fillRect(0, canvas.height-88, canvas.width, 88);

  drawBlock(basket.x, basket.y, basket.width, basket.height, '#8b5e3c');
  const studs = Math.max(1, Math.floor(basket.width/30));
  for(let i=0;i<studs;i++){
    const sx = basket.x + 8 + i*(basket.width-16)/(studs-1||1);
    drawStud(sx, basket.y - 8);
  }

  for(const c of coins){
    if(c.type === 'yellow') drawBlock(c.x, c.y, c.w, c.h, '#ffd60a');
    else if(c.type === 'green') drawBlock(c.x, c.y, c.w, c.h, '#5be07a');
    else drawBlock(c.x, c.y, c.w, c.h, '#e65252');
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.fillRect(c.x + 4, c.y + 4, c.w - 8, c.h - 8);
  }
}

function drawBlock(x,y,w,h,color){
  ctx.fillStyle = color;
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = shadeColor(color, -18);
  ctx.fillRect(x, y + h - Math.max(2, Math.floor(h*0.25)), w, Math.max(2, Math.floor(h*0.25)));
  ctx.strokeStyle = '#00000022';
  ctx.strokeRect(x+0.5, y+0.5, w-1, h-1);
}
function drawStud(cx, cy){
  ctx.fillStyle = '#ffebc8';
  ctx.beginPath();
  ctx.ellipse(cx, cy, 8, 6, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = '#00000022';
  ctx.stroke();
}
function shadeColor(col, percent) {
  try{
    const f = parseInt(col.slice(1),16),t=percent<0?0:255,p= Math.abs(percent)/100;
    const R = Math.round((t - (f>>16)) * p) + (f>>16);
    const G = Math.round((t - (f>>8 & 0x00FF)) * p) + (f>>8 & 0x00FF);
    const B = Math.round((t - (f & 0x0000FF)) * p) + (f & 0x0000FF);
    return "#" + (0x1000000 + (R<<16) + (G<<8) + B).toString(16).slice(1);
  }catch(e){return col}
}

let rafId = null;
function loop(ts){
  if(!lastTime) lastTime = ts;
  const dt = ts - lastTime;
  lastTime = ts;
  update(dt);
  draw();
  if(!gameOver) rafId = requestAnimationFrame(loop);
}

function endGame(){
  gameOver = true;
  bonusText.style.display = 'none';
  setTimeout(()=>{
    startButton.textContent = 'Opet pokreni igru';
    startButton.style.display = 'block';
  }, 450);
}

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width * canvas.width;
  const minX = -basket.width;
  const maxX = canvas.width;
  basket.x = clamp(x - basket.width/2, minX, maxX);
});

let touchStartX = null;
let basketStartX = null;
canvas.addEventListener('touchstart', e => {
  if(e.touches.length === 1){
    touchStartX = e.touches[0].clientX;
    basketStartX = basket.x;
  }
});
canvas.addEventListener('touchmove', e => {
  if(touchStartX !== null && e.touches.length === 1){
    const dx = e.touches[0].clientX - touchStartX;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const minX = -basket.width;
    const maxX = canvas.width;
    basket.x = clamp(basketStartX + dx * scaleX, minX, maxX);
    e.preventDefault();
  }
});
canvas.addEventListener('touchend', e => {
  touchStartX = null;
  basketStartX = null;
});

function clamp(v,a,b){return Math.max(a, Math.min(b, v));}

function startCountdown(cb){
  ensureAudio();
  playStartClick();
  let count = 3;
  countdownEl.style.display = 'block';
  countdownEl.textContent = count;
  playTick();
  const tick = setInterval(()=>{
    count--;
    if(count > 0){
      countdownEl.textContent = count;
      playTick();
    } else {
      clearInterval(tick);
      countdownEl.style.display = 'none';
      cb();
    }
  }, 1000);
}

startButton.addEventListener('click', () => {
  startButton.style.display = 'none';
  resetGame();
  startCountdown(() => {
    lastTime = 0;
    lastSpawn = performance.now();
    rafId = requestAnimationFrame(loop);
  });
});

</script>
</body>
</html>
