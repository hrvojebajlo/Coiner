<!DOCTYPE html>
<html lang="hr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Coiner</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%; background: white; display: flex; justify-content: center; align-items: center;
  }
  #game-container {
    width: 100vw;
    max-width: 400px;
    aspect-ratio: 9 / 16;
    box-sizing: border-box;
    border: 2px solid #888; /* sivi obrub unutra */
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    touch-action: none;
    user-select: none;
    background: white;
  }
</style>
</head>
<body>
<div id="game-container">
  <canvas id="game" width="360" height="640"></canvas>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const GAME_WIDTH = canvas.width;
const GAME_HEIGHT = canvas.height;

let basket = {
  width: 80,
  height: 28,
  x: (GAME_WIDTH - 80) / 2,
  y: GAME_HEIGHT - 88 - 28,
  speed: 0
};

let coins = [];
let explosions = [];

let lastTime = 0;
let spawnTimer = 0;
let spawnInterval = 1500; 
let gameOver = false;
let score = 0;
let bonusActive = false;
let bonusTimeLeft = 0;
let lastGreenTime = 0;
let lastRedTime = 0;

let gameStarted = false;
let explosionPlaying = false;

const basketNormalWidth = 80;
const basketBonusWidth = 160;
const basketHeight = 28;
const basketY = GAME_HEIGHT - 88 - basketHeight;

const coinSize = 30;

const yellowScore = 1;
const greenScore = 2;

function clamp(num, min, max) {
  return Math.min(Math.max(num, min), max);
}

function createCoin(type){
  return {
    x: Math.random() * (GAME_WIDTH - coinSize),
    y: -coinSize,
    w: coinSize,
    h: coinSize,
    type: type,
    exploded: false
  };
}

function drawBlock(x, y, w, h, color){
  ctx.fillStyle = color;
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillRect(x+6, y+6, w-12, h-12);
  const studs = 3;
  for(let i=0; i<studs; i++){
    ctx.beginPath();
    ctx.ellipse(x + 8 + i*(w-16)/(studs-1), y+8, 8, 6, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fill();
  }
}

function drawExplosions(){
  const now = performance.now();
  explosions = explosions.filter(e => now - e.start < 400);
  explosions.forEach(e => {
    const elapsed = now - e.start;
    const alpha = 1 - elapsed / 400;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.arc(e.x, e.y, 30 + elapsed / 10, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  });
  if(explosions.length === 0 && explosionPlaying){
    explosionPlaying = false;
  }
}

function spawnCoin(){
  if(gameOver || explosionPlaying) return;

  const yellowCount = coins.filter(c => c.type === 'yellow').length;

  let rand = Math.random();

  if(yellowCount < 2 && rand < 0.85){
    coins.push(createCoin('yellow'));
  } else if(rand < 0.95 && Date.now() - lastGreenTime > 30000){
    coins.push(createCoin('green'));
    lastGreenTime = Date.now();
  } else if(Date.now() - lastRedTime > 10000){
    coins.push(createCoin('red'));
    lastRedTime = Date.now();
  }
}

function update(delta){
  if(gameOver || explosionPlaying) return;

  spawnTimer += delta;
  if(spawnTimer > spawnInterval){
    spawnCoin();
    spawnTimer = 0;
    if(spawnInterval > 600) spawnInterval -= 10;
  }

  for(let i = coins.length-1; i >= 0; i--){
    let c = coins[i];
    c.y += 0.2 * delta * (1 + (1500 - spawnInterval)/700);

    if(c.y + c.h > GAME_HEIGHT) c.y = GAME_HEIGHT - c.h;

    if(c.type === 'yellow'){
      if(c.y + 1 > basket.y + basket.height){
        addExplosion(c.x + c.w/2, basket.y + basket.height, '#ffd60a');
        gameOver = true;
        coins.splice(i,1);
        return;
      }
    }

    if(c.type === 'green'){
      if(c.y + 1 > basket.y + basket.height){
        addExplosion(c.x + c.w/2, basket.y + basket.height, '#5be07a');
        coins.splice(i,1);
        return;
      }
    }

    if(c.type === 'red'){
      if(c.y > basket.y + basket.height){
        coins.splice(i,1);
        continue;
      }
    }

    if(c.y + c.h > basket.y &&
       c.x + c.w > basket.x &&
       c.x < basket.x + basket.width){

      if(c.type === 'yellow'){
        score += bonusActive ? yellowScore * 2 : yellowScore;
        coins.splice(i,1);
        playSound('yellow');
      } else if(c.type === 'green'){
        score += bonusActive ? greenScore * 2 : greenScore;
        bonusActive = true;
        bonusTimeLeft = 10000;
        basket.width = basketBonusWidth;
        basket.x = clamp(basket.x, -basket.width + basketNormalWidth, GAME_WIDTH);
        coins.splice(i,1);
        playSound('green');
      } else if(c.type === 'red'){
        if(!c.exploded){
          addExplosion(c.x + c.w/2, c.y + c.h/2, '#e65252');
          c.exploded = true;
          playSound('red');
          gameOver = true;
          explosionPlaying = true;
          coins.splice(i,1);
          return;
        }
      }
    }
  }

  if(bonusActive){
    bonusTimeLeft -= delta;
    if(bonusTimeLeft <= 0){
      bonusActive = false;
      basket.width = basketNormalWidth;
      basket.x = clamp(basket.x, -basket.width + basketNormalWidth, GAME_WIDTH);
      bonusTimeLeft = 0;
    }
  }
}

function playSound(type){
  if(!window.AudioContext) return;

  if(type === 'yellow'){
    beep(800, 0.1);
  } else if(type === 'green'){
    beep(1200, 0.2);
  } else if(type === 'red'){
    beep(400, 0.4);
  } else if(type === 'tick'){
    beep(900, 0.05);
  } else if(type === 'start'){
    beep(1000, 0.15);
  }
}

function beep(freq, duration){
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();

  oscillator.type = 'square';
  oscillator.frequency.value = freq;

  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  oscillator.start();

  gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);

  oscillator.stop(audioCtx.currentTime + duration);
}

function draw(){
  ctx.clearRect(0,0,GAME_WIDTH,GAME_HEIGHT);

  ctx.fillStyle = '#f3f3f3';
  ctx.fillRect(0, GAME_HEIGHT-88, GAME_WIDTH, 88);

  ctx.fillStyle = '#8b5e3c';
  ctx.fillRect(basket.x, basket.y, basket.width, basket.height);
  const studs = Math.max(1, Math.floor(basket.width/30));
  for(let i=0;i<studs;i++){
    const sx = basket.x + 8 + i*(basket.width-16)/(studs-1||1);
    ctx.fillStyle = '#ffebc8';
    ctx.beginPath();
    ctx.ellipse(sx, basket.y - 8, 8, 6, 0, 0, Math.PI*2);
    ctx.fill();
  }

  for(const c of coins){
    if(c.type === 'yellow') drawBlock(c.x, c.y, c.w, c.h, '#ffd60a');
    else if(c.type === 'green') drawBlock(c.x, c.y, c.w, c.h, '#5be07a');
    else drawBlock(c.x, c.y, c.w, c.h, '#e65252');
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.fillRect(c.x + 4, c.y + 4, c.w - 8, c.h - 8);
  }

  drawExplosions();

  ctx.lineWidth = 2;
  ctx.strokeStyle = '#888';
  ctx.strokeRect(1, 1, GAME_WIDTH - 2, GAME_HEIGHT - 2);

  ctx.font = 'bold 24px Arial';
  ctx.fillStyle = '#333';
  ctx.textAlign = 'left';
  ctx.fillText(`Bodovi: ${score}`, 10, 30);

  if(bonusActive){
    ctx.fillStyle = '#27ae60';
    ctx.fillText(`Bonus: ${(bonusTimeLeft/1000).toFixed(1)}s`, GAME_WIDTH - 140, 30);
  }

  if(!gameStarted){
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    ctx.font = 'bold 36px Arial';
    ctx.fillText('Započni igru', GAME_WIDTH/2, GAME_HEIGHT/2);
  }

  if(gameOver && !explosionPlaying){
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);

    const boxWidth = 280;
    const boxHeight = 140;
    const boxX = (GAME_WIDTH - boxWidth) / 2;
    const boxY = (GAME_HEIGHT - boxHeight) / 2;

    ctx.fillStyle = '#e65252';
    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

    ctx.lineWidth = 2;
    ctx.strokeStyle = 'black';
    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

    ctx.fillStyle = 'white';
    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';

    ctx.fillText(`Vaš rezultat: ${score}`, GAME_WIDTH / 2, boxY + 45);

    ctx.font = 'bold 30px Arial';
    ctx.fillText('Ponovno započni igru', GAME_WIDTH / 2, boxY + 95);
  }
}

function addExplosion(x,y,color){
  explosions.push({x,y,color,start: performance.now()});
}

function resetGame(){
  score = 0;
  bonusActive = false;
  bonusTimeLeft = 0;
  basket.width = basketNormalWidth;
  basket.x = (GAME_WIDTH - basket.width) / 2;
  coins = [];
  explosions = [];
  spawnInterval = 1500;
  lastGreenTime = 0;
  lastRedTime = 0;
  gameOver = false;
  gameStarted = false;
  explosionPlaying = false;
  draw();
}

canvas.addEventListener('mousemove', e => {
  if(gameOver || explosionPlaying || !gameStarted) return;
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width * GAME_WIDTH;
  basket.x = clamp(x - basket.width / 2, -basket.width + basketNormalWidth, GAME_WIDTH);
});

canvas.addEventListener('touchmove', e => {
  if(gameOver || explosionPlaying || !gameStarted) return;
  for(let t of e.touches){
    if(pointerId === null || pointerId === t.identifier){
      pointerId = t.identifier;
      const rect = canvas.getBoundingClientRect();
      const x = (t.clientX - rect.left) / rect.width * GAME_WIDTH;
      basket.x = clamp(x - basket.width / 2, -basket.width + basketNormalWidth, GAME_WIDTH);
      e.preventDefault();
      break;
    }
  }
});

canvas.addEventListener('touchend', e => {
  for(let t of e.changedTouches){
    if(t.identifier === pointerId){
      pointerId = null;
    }
  }
});

let pointerId = null;

canvas.addEventListener('click', onPointerStart);
canvas.addEventListener('touchstart', e => { e.preventDefault(); onPointerStart(e); });

function onPointerStart(e){
  if(!gameStarted){
    gameStarted = true;
    lastTime = 0;
    requestAnimationFrame(gameLoop);
  } else if(gameOver && !explosionPlaying){
    resetGame();
    gameStarted = true;
    lastTime = 0;
    requestAnimationFrame(gameLoop);
  }
}

function gameLoop(timestamp=0){
  if(!lastTime) lastTime = timestamp;
  const delta = timestamp - lastTime;
  lastTime = timestamp;

  update(delta);
  draw();

  if(!gameOver){
    requestAnimationFrame(gameLoop);
  } else if(gameOver && explosionPlaying){
    requestAnimationFrame(gameLoop);
  }
}

resetGame();
</script>
</body>
</html>
